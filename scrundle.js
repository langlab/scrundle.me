// Generated by CoffeeScript 1.3.3
var Bundler, Script, User, app, ck, db, express, io, mongoose, mongooseAuth, sio, store, util, _;

express = require('express');

store = new express.session.MemoryStore();

util = require('util');

ck = require('coffeekup');

_ = require('underscore');

db = require('./src/srv/db');

User = db.User;

Script = db.Script;

mongoose = db.mongoose;

Bundler = require('./src/srv/bundler');

io = require('socket.io');

mongooseAuth = require('mongoose-auth');

app = express.createServer();

sio = io.listen(app);

app.configure(function() {
  app.use(express.methodOverride());
  app.use(express.cookieParser());
  app.use(express.session({
    secret: 'keyboardCat',
    key: 'express.sid',
    store: store
  }));
  app.use(express.bodyParser());
  app.use(mongooseAuth.middleware());
  app.use(express["static"]("" + __dirname + "/pub"));
  app.set('views', "" + __dirname + "/src/views");
  app.set('view options', {
    layout: false
  });
  app.set('view engine', 'coffee');
  app.register('.coffee', require('coffeekup').adapters.express);
  return app.use(express.errorHandler());
});

mongooseAuth.helpExpress(app);

app.get('/', function(req, res) {
  return res.render('index', {
    user: req.user,
    session: req.session
  });
});

app.get('/favicon.ico', function(req, res) {
  return res.sendfile("" + __dirname + "/pub/img/favicon.ico");
});

app.get('/ck.js', function(req, res) {
  return res.sendfile("" + __dirname + "/node_modules/coffeekup/lib/coffeekup.js");
});

app.get('/github/callback', function(req, res) {
  console.log(req.query);
  return res.redirect('/');
});

app.get('/twitter/callback', function(req, res) {
  console.log(req.query);
  return res.redirect('/');
});

app.get(/^\/js\/([^e]+)(\/(.+)\.js)?/, function(req, res) {
  var bd;
  console.log(req.params);
  bd = new Bundler();
  bd.getBundle(req.params[0].split('/'));
  return bd.on('bundle', function(bundle) {
    return res.send(bundle, {
      'Content-type': 'text/javascript'
    });
  });
});

app.get('/s', function(req, res) {
  return store.get(req.session.id, function(e, s) {
    return res.json({
      id: req.session.id,
      ck: req.cookies,
      e: e,
      s: s
    });
  });
});

/*
io.set 'authorization', (data, accept)->
    # check if there's a cookie header
    if (data.headers.cookie)
        # if there is, parse the cookie
        data.cookie = parseCookie(data.headers.cookie)
        # note that you will need to use the same key to grad the
        # session id, as you specified in the Express setup.
        data.sessionID = data.cookie['express.sid']
    else
       # if there isn't, turn down the connection with a message
       # and leave the function.
       return accept('No cookie transmitted.', false)
    # accept the incoming connection
    accept(null, true)
*/


sio.sockets.on('connection', function(socket) {
  var cookieStr, ssid;
  console.log('session: ', socket.handshake);
  cookieStr = _.find(socket.handshake.headers.cookie.split(';'), function(i) {
    return /express\.sid/.test(i);
  });
  ssid = unescape(cookieStr != null ? cookieStr.split('=')[1] : void 0);
  console.log('ssid: ', ssid);
  socket.on('script', function(data, cb) {
    var code, list, q,
      _this = this;
    console.log('read: ', JSON.stringify(data));
    switch (data.method) {
      case 'codeExists':
        if ((code = data.code)) {
          return Script.findOne({
            code: code
          }, function(err, script) {
            console.log('hi: ', script);
            return cb(script);
          });
        }
        break;
      case 'read':
        if ((code = data.options.code)) {
          return Script.findOne({
            code: code
          }, function(err, script) {
            return _this.emit('script', 'read', script);
          });
        } else if ((list = data.options.list)) {
          return Script.list(list, function(err, matchingScripts) {
            console.log('sending ', _.pluck(matchingScripts, 'code'));
            return _this.emit('script', 'read', matchingScripts);
          });
        } else if ((q = data.options.query)) {
          return Script.search(q, function(err, matchingScripts) {
            console.log('sending ', _.pluck(matchingScripts, 'code'));
            return _this.emit('script', 'read', matchingScripts);
          });
        } else {
          return Script.find(function(err, scripts) {
            return _this.emit('script', 'read', scripts);
          });
        }
    }
  });
  return socket.on('scrundle', function(codes) {
    var bd,
      _this = this;
    console.log('recv:', codes);
    bd = new Bundler();
    bd.getBundle(codes);
    bd.on('bundle', function(bundle) {
      return _this.emit('scrundle:source', bundle);
    });
    return bd.on('progress', function(count) {
      return _this.emit('scrundle:progress', count);
    });
  });
});

app.listen(8080);
